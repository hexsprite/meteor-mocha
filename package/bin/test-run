#!/usr/bin/env node
/* eslint-disable no-console, max-len, complexity */

// Suppress experimental warnings (e.g., fs.glob) to keep output clean
process.removeAllListeners('warning')
/**
 * CLI client for test daemon
 *
 * Usage:
 *   ./scripts/test-run                    # Run all tests (auto-starts daemon)
 *   ./scripts/test-run Calendar           # Filter by pattern
 *   ./scripts/test-run -t Calendar -t sync # Multiple patterns (OR)
 *   ./scripts/test-run Calendar -i        # Exclude pattern
 *   ./scripts/test-run --json             # JSON output for LLM/scripting
 *   ./scripts/test-run Calendar --json    # Filtered tests with JSON output
 *   ./scripts/test-run daemon start       # Start daemon explicitly
 *   ./scripts/test-run daemon stop        # Stop daemon
 *   ./scripts/test-run daemon status      # Check daemon status
 *   ./scripts/test-run daemon logs        # Show daemon logs
 *   ./scripts/test-run daemon logs -t    # Stream daemon logs (tail -f)
 *   ./scripts/test-run Calendar -w       # Watch mode: re-run on file changes
 */

const http = require('http')
const { spawn, execSync } = require('child_process')
const fs = require('fs')
const path = require('path')

const port = process.env.TEST_PORT || 9100
const pidFile = path.join(process.cwd(), '.meteor', 'local', 'test-daemon.pid')
const logFile = path.join(process.cwd(), '.meteor', 'local', 'test-daemon.log')
const lockFile = path.join(process.cwd(), '.meteor', 'local', 'test-daemon.lock')
const cacheFile = path.join(process.cwd(), '.meteor', 'local', 'test-cache.json')
const CACHE_TTL_MS = 60000 // 1 minute

// Colors
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  dim: '\x1b[2m',
  reset: '\x1b[0m',
}

// Check if daemon is running
function isDaemonRunning() {
  return new Promise((resolve) => {
    const req = http.get(`http://localhost:${port}/test/health`, (res) => {
      resolve(res.statusCode === 200)
    })
    req.on('error', () => resolve(false))
    req.setTimeout(1000, () => {
      req.destroy()
      resolve(false)
    })
  })
}

// Read PID from file
function readPid() {
  try {
    return parseInt(fs.readFileSync(pidFile, 'utf8').trim(), 10)
  } catch {
    return null
  }
}

// Write PID to file
function writePid(pid) {
  const dir = path.dirname(pidFile)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
  fs.writeFileSync(pidFile, String(pid))
}

// Remove PID file
function removePid() {
  try {
    fs.unlinkSync(pidFile)
  } catch {
    // Ignore if doesn't exist
  }
}

// Check if process is running
function isProcessRunning(pid) {
  try {
    process.kill(pid, 0)
    return true
  } catch {
    return false
  }
}

// Lock file management to prevent race conditions
const LOCK_STALE_MS = 180000 // 3 minutes - lock is stale if older than this

function acquireLock() {
  const dir = path.dirname(lockFile)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }

  // Check for existing lock
  try {
    const lockData = fs.readFileSync(lockFile, 'utf8')
    const { timestamp, pid } = JSON.parse(lockData)
    const age = Date.now() - timestamp

    // Lock is stale if too old or process is dead
    if (age < LOCK_STALE_MS && isProcessRunning(pid)) {
      return false // Lock is held by another process
    }
    // Stale lock - we can take over
    console.log(`${colors.dim}Cleaning up stale lock file${colors.reset}`)
  } catch {
    // No lock file or invalid - we can acquire
  }

  // Write our lock
  fs.writeFileSync(lockFile, JSON.stringify({
    timestamp: Date.now(),
    pid: process.pid,
  }))
  return true
}

function releaseLock() {
  try {
    // Only release if we own the lock
    const lockData = fs.readFileSync(lockFile, 'utf8')
    const { pid } = JSON.parse(lockData)
    if (pid === process.pid) {
      fs.unlinkSync(lockFile)
    }
  } catch {
    // Lock file doesn't exist or can't be read - that's fine
  }
}

/**
 * Tail the daemon log file during startup to show errors in real-time
 */
function tailLogFile() {
  let tail = null
  let lastSize = 0

  const startTailing = () => {
    // Start from current file size so we only see NEW content
    try {
      lastSize = fs.statSync(logFile).size
    } catch {
      lastSize = 0 // File doesn't exist yet
    }

    const checkFile = () => {
      try {
        const stat = fs.statSync(logFile)
        if (stat.size > lastSize) {
          const fd = fs.openSync(logFile, 'r')
          const buffer = Buffer.alloc(stat.size - lastSize)
          fs.readSync(fd, buffer, 0, buffer.length, lastSize)
          fs.closeSync(fd)

          const content = buffer.toString()
          for (const line of content.split('\n')) {
            if (line.trim()) {
              // Color errors red, warnings yellow
              if (line.includes('Error') || line.includes('error:')) {
                console.log(`${colors.red}[daemon] ${line}${colors.reset}`)
              } else if (line.includes('Warning') || line.includes('warning')) {
                console.log(`${colors.yellow}[daemon] ${line}${colors.reset}`)
              } else {
                console.log(`${colors.dim}[daemon] ${line}${colors.reset}`)
              }
            }
          }
          lastSize = stat.size
        }
      } catch {
        // File doesn't exist yet - that's fine
      }
    }

    // Poll every 500ms
    tail = setInterval(checkFile, 500)
    checkFile() // Check immediately
  }

  const stopTailing = () => {
    if (tail) {
      clearInterval(tail)
      tail = null
    }
  }

  return { start: startTailing, stop: stopTailing }
}

/**
 * Get latest mtime across all project files
 */
async function getProjectMtime() {
  const patterns = [
    'imports/**/*.{ts,tsx,js,jsx}',
    'server/**/*.{ts,js}',
    'client/**/*.{ts,tsx,js,jsx}',
  ]

  let latestMtime = 0

  for (const pattern of patterns) {
    const fullPattern = path.join(process.cwd(), pattern)
    for await (const file of fs.promises.glob(fullPattern)) {
      try {
        const stat = fs.statSync(file)
        if (stat.mtimeMs > latestMtime) latestMtime = stat.mtimeMs
      } catch {
        // File gone - ignore
      }
    }
  }

  return latestMtime
}

/**
 * Read cache file
 */
function readCache() {
  try {
    return JSON.parse(fs.readFileSync(cacheFile, 'utf8'))
  } catch {
    return null
  }
}

/**
 * Write cache file
 */
function writeCache(data) {
  const dir = path.dirname(cacheFile)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
  fs.writeFileSync(cacheFile, JSON.stringify(data, null, 2))
}

/**
 * Check if we can use cached result
 */
async function checkCache() {
  const cache = readCache()
  if (!cache?.lastRun) return null

  const { timestamp, projectMtime, output, exitCode, failures, jsonResult } = cache.lastRun

  // TTL check
  const age = Date.now() - timestamp
  if (age > CACHE_TTL_MS) return null

  // File change check
  const currentMtime = await getProjectMtime()
  if (currentMtime > projectMtime) return null

  return { output, exitCode, failures, age, jsonResult }
}

/**
 * Save result to cache
 */
async function saveCache(output, exitCode, failures, jsonResult = null) {
  const projectMtime = await getProjectMtime()
  writeCache({
    lastRun: {
      timestamp: Date.now(),
      projectMtime,
      output,
      exitCode,
      failures,
      jsonResult, // Store structured JSON for --json mode
    }
  })
}

async function waitForLockOrDaemon() {
  const startTime = Date.now()
  const maxWait = 180000 // 3 minutes max wait

  while (Date.now() - startTime < maxWait) {
    // If daemon is now running, we're good
    if (await isDaemonRunning()) {
      return { ready: true }
    }

    // Try to acquire lock
    if (acquireLock()) {
      // Check one more time - daemon might have started while we waited
      if (await isDaemonRunning()) {
        releaseLock()
        return { ready: true }
      }
      return { locked: true }
    }

    // Lock is held - wait and retry
    process.stdout.write('.')
    await new Promise(r => setTimeout(r, 2000))
  }

  return { timeout: true }
}

// Start daemon in background
async function startDaemon(quiet = false) {
  // Check if already running
  if (await isDaemonRunning()) {
    if (!quiet) console.log(`${colors.green}Daemon already running on port ${port}${colors.reset}`)
    return true
  }

  // Try to get lock or wait for another process to start daemon
  if (!quiet) console.log(`${colors.dim}Checking for other startup processes...${colors.reset}`)
  const lockResult = await waitForLockOrDaemon()

  if (lockResult.ready) {
    if (!quiet) console.log(`${colors.green}Daemon already running on port ${port}${colors.reset}`)
    return true
  }

  if (lockResult.timeout) {
    console.error(`${colors.red}Timeout waiting for daemon startup${colors.reset}`)
    return false
  }

  // We have the lock - we're responsible for starting the daemon
  try {
    // Check if stale PID file
    const existingPid = readPid()
    if (existingPid && !isProcessRunning(existingPid)) {
      if (!quiet) console.log(`${colors.dim}Cleaning up stale PID file${colors.reset}`)
      removePid()
    }

    if (!quiet) console.log(`${colors.cyan}Starting test daemon...${colors.reset}`)

    // Ensure log directory exists
    const logDir = path.dirname(logFile)
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true })
    }

    // Start daemon in background
    const out = fs.openSync(logFile, 'a')
    const err = fs.openSync(logFile, 'a')

    const child = spawn('npm', ['run', 'test:daemon'], {
      detached: true,
      stdio: ['ignore', out, err],
      cwd: process.cwd(),
    })

    writePid(child.pid)
    child.unref()

    if (!quiet) {
      console.log(`${colors.dim}Daemon PID: ${child.pid}${colors.reset}`)
      console.log(`${colors.dim}Log file: ${logFile}${colors.reset}`)
    }

    // Start tailing log file to show startup progress/errors (skip in quiet mode)
    const tailer = quiet ? null : tailLogFile()
    if (tailer) tailer.start()

    // Wait for daemon to be ready
    if (!quiet) console.log(`${colors.dim}Waiting for daemon to be ready...${colors.reset}`)
    const startTime = Date.now()
    const timeout = 120000 // 2 minutes

    while (Date.now() - startTime < timeout) {
      if (await isDaemonRunning()) {
        if (tailer) tailer.stop()
        if (!quiet) console.log(`\n${colors.green}Daemon ready with latest code!${colors.reset}\n`)
        releaseLock()
        return true
      }
      await new Promise(r => setTimeout(r, 2000))
    }

    if (tailer) tailer.stop()
    console.error(`\n${colors.red}Daemon failed to start within ${timeout / 1000}s${colors.reset}`)
    console.error(`${colors.dim}See errors above or check: ${logFile}${colors.reset}`)
    releaseLock()
    return false
  } catch (err) {
    releaseLock()
    throw err
  }
}

// Stop daemon
async function stopDaemon() {
  const pid = readPid()
  if (pid && isProcessRunning(pid)) {
    console.log(`${colors.yellow}Stopping daemon (PID: ${pid})...${colors.reset}`)
    try {
      // Kill the process group to get all child processes
      process.kill(-pid, 'SIGTERM')
    } catch {
      // Try killing just the process
      try {
        process.kill(pid, 'SIGTERM')
      } catch {
        // Process already dead
      }
    }
    removePid()
    console.log(`${colors.green}Daemon stopped${colors.reset}`)
  } else {
    // Try to find and kill by port
    try {
      const result = execSync(`lsof -ti:${port}`).toString().trim()
      if (result) {
        const pids = result.split('\n')
        for (const p of pids) {
          try {
            process.kill(parseInt(p, 10), 'SIGTERM')
            console.log(`${colors.yellow}Killed process ${p} on port ${port}${colors.reset}`)
          } catch {
            // Process already dead
          }
        }
        removePid()
        console.log(`${colors.green}Daemon stopped${colors.reset}`)
      } else {
        console.log(`${colors.dim}No daemon running${colors.reset}`)
      }
    } catch {
      console.log(`${colors.dim}No daemon running${colors.reset}`)
    }
  }
}

// Show daemon status
async function daemonStatus() {
  const running = await isDaemonRunning()
  const pid = readPid()

  if (running) {
    console.log(`${colors.green}Daemon is running on port ${port}${colors.reset}`)
    if (pid) {
      console.log(`${colors.dim}PID: ${pid}${colors.reset}`)
    }
    // Get health info
    try {
      const health = await new Promise((resolve, reject) => {
        http.get(`http://localhost:${port}/test/health`, (res) => {
          let data = ''
          res.on('data', chunk => data += chunk)
          res.on('end', () => resolve(JSON.parse(data)))
        }).on('error', reject)
      })
      console.log(`${colors.dim}Suites: ${health.suites}${colors.reset}`)
    } catch {
      // Ignore
    }
  } else {
    console.log(`${colors.red}Daemon is not running${colors.reset}`)
    if (pid && isProcessRunning(pid)) {
      console.log(`${colors.yellow}PID file exists (${pid}) but daemon not responding${colors.reset}`)
    }
  }
}

// Handle daemon commands
async function handleDaemonCommand(cmd) {
  switch (cmd) {
    case 'start':
      await startDaemon()
      process.exit(0)
      break
    case 'stop':
      await stopDaemon()
      process.exit(0)
      break
    case 'status':
      await daemonStatus()
      process.exit(0)
      break
    case 'restart':
      await stopDaemon()
      await new Promise(r => setTimeout(r, 1000))
      await startDaemon()
      process.exit(0)
      break
    case 'logs':
      const tailMode = args.includes('-t') || args.includes('--tail')
      if (fs.existsSync(logFile)) {
        console.log(`${colors.dim}Log file: ${logFile}${colors.reset}\n`)
        if (tailMode) {
          // Stream logs continuously
          console.log(`${colors.dim}Tailing logs (Ctrl+C to exit)...${colors.reset}\n`)
          const tail = spawn('tail', ['-n', '100', '-f', logFile], { stdio: 'inherit' })
          tail.on('close', () => process.exit(0))
          process.on('SIGINT', () => {
            tail.kill()
            process.exit(0)
          })
        } else {
          // One-shot: print and exit
          console.log(fs.readFileSync(logFile, 'utf8'))
          process.exit(0)
        }
      } else {
        console.log(`${colors.dim}No log file found at ${logFile}${colors.reset}`)
        process.exit(0)
      }
      break
    default:
      console.error(`Unknown daemon command: ${cmd}`)
      console.error('Usage: test-run daemon [start|stop|status|restart|logs]')
      process.exit(1)
  }
}

// Parse args
const args = process.argv.slice(2)
const testNamePatterns = []
let filePattern = ''
let invert = false
let watchMode = false
let jsonMode = false
let snapshotUpdate = false

/**
 * Check if an argument looks like a test file or directory path
 * Supports: .app-spec., .app-test., .spec., .test., or paths ending with /
 */
function isFilePath(arg) {
  return arg.includes('.app-spec.') ||
         arg.includes('.app-test.') ||
         arg.includes('.spec.') ||
         arg.includes('.test.') ||
         arg.endsWith('/') ||
         arg.includes('/') && !arg.includes('.')  // directory path like imports/api/calendar
}

/**
 * Normalize a file path to be relative to project root
 * Strips leading slashes and ensures forward slashes
 */
function normalizePath(filepath) {
  if (!filepath) return filepath
  // Remove leading slash if present
  let normalized = filepath.replace(/^\/+/, '')
  // Ensure forward slashes (Windows compat)
  normalized = normalized.replace(/\\/g, '/')
  return normalized
}

// Check for daemon commands first
if (args[0] === 'daemon') {
  handleDaemonCommand(args[1] || 'status')
} else {
  // Parse test args
  for (let i = 0; i < args.length; i++) {
    const arg = args[i]

    // Test name patterns (-t, --testNamePattern, --grep, -g)
    if (arg === '-t' || arg === '--testNamePattern' || arg === '--grep' || arg === '-g') {
      if (args[i + 1]) testNamePatterns.push(args[++i])
    }
    // File pattern (-f, --file)
    else if (arg === '-f' || arg === '--file') {
      if (args[i + 1]) filePattern = normalizePath(args[++i])
    }
    // Invert
    else if (arg === '--invert' || arg === '-i') {
      invert = true
    }
    // Watch mode
    else if (arg === '--watch' || arg === '-w') {
      watchMode = true
    }
    // JSON output mode
    else if (arg === '--json') {
      jsonMode = true
    }
    // Snapshot update mode
    else if (arg === '--snapshot-update' || arg === '-u') {
      snapshotUpdate = true
    }
    // Help
    else if (arg === '--help' || arg === '-h') {
      console.log(`
Usage: test-run [options] [pattern|filepath...]
       test-run daemon [start|stop|status|restart]

Options:
  -t, --testNamePattern <pattern>  Filter by test name (can repeat)
  -g, --grep <pattern>             Alias for -t
  -f, --file <path>                Run tests in specific file
  -i, --invert                     Invert pattern match
  -w, --watch                      Watch mode: re-run on daemon restart
  --json                           Output results as JSON (for LLM/scripting)
  -u, --snapshot-update            Update snapshots (sets SNAPSHOT_UPDATE=1)
  --no-cache                       Force run, skip cache check
  -h, --help                       Show this help

Daemon Commands:
  daemon start     Start the test daemon in background
  daemon stop      Stop the running daemon
  daemon status    Check if daemon is running
  daemon restart   Restart the daemon
  daemon logs [-t] Show daemon log file (-t to tail/follow)

Multiple patterns use OR logic.
File paths are auto-detected (*.app-spec.ts, *.spec.ts).
The daemon auto-starts if not running when tests are requested.

Examples:
  test-run                                      Run all tests
  test-run Calendar                             Tests matching "Calendar"
  test-run -t Calendar -t sync                  Tests matching "Calendar" OR "sync"
  test-run Calendar -i                          Exclude tests matching "Calendar"
  test-run imports/api/calendar/FullSync.app-spec.ts   Run specific file
  test-run -f FullSync.app-spec.ts              Run file by partial path
  test-run FullSync.app-spec.ts -t "clears"     File + grep filter
  test-run Calendar -w                          Watch mode: re-run on changes
  test-run --json                               JSON output for LLM consumption
  test-run Calendar --json | jq '.stats'        Filter JSON with jq
  test-run daemon stop                          Stop the daemon
`)
      process.exit(0)
    }
    // Positional args: detect if file path or grep pattern
    else if (!arg.startsWith('-')) {
      if (isFilePath(arg)) {
        filePattern = normalizePath(arg)
      } else {
        testNamePatterns.push(arg)
      }
    }
  }

  // Run tests
  runTests()
}

async function runTests() {
  // Check cache for full test runs (no grep, no file filter, no invert)
  // Cache checks file mtimes, so changed files will invalidate it automatically
  const isFullRun = testNamePatterns.length === 0 && !filePattern && !invert
  const noCache = args.includes('--no-cache')

  if (isFullRun && !noCache) {
    const cached = await checkCache()
    if (cached) {
      const ageSeconds = Math.round(cached.age / 1000)

      if (jsonMode) {
        // Skip cache if it doesn't have JSON data (was populated without --json)
        if (!cached.jsonResult) {
          // Fall through to run tests fresh with JSON reporter
        } else {
          // Return cached JSON result
          // For full runs (cached), grep/file/invert are always null/false
          const output = {
            success: cached.exitCode === 0,
            grep: null,
            file: null,
            invert: false,
            cached: true,
            cached_age_seconds: ageSeconds,
            hint: 'Cached result. File changes are auto-detected - just re-run to get fresh results.',
            ...cached.jsonResult,
          }
          console.log(JSON.stringify(output, null, 2))
          process.exitCode = cached.exitCode
          return
        }
      } else {
        console.log(`\n${colors.cyan}Using cached result (no files changed, ${ageSeconds}s ago)${colors.reset}\n`)
        console.log(cached.output)
        console.log(`${colors.dim}Test run complete: ${cached.failures} failures (cached)${colors.reset}\n`)
        process.exitCode = cached.exitCode
        return
      }
    }
  }

  // Check if daemon is running, auto-start if not
  if (!await isDaemonRunning()) {
    if (!jsonMode) {
      console.log(`${colors.yellow}Daemon not running, starting fresh (will load latest code)...${colors.reset}\n`)
    }
    const started = await startDaemon(jsonMode) // Pass quiet flag for JSON mode
    if (!started) {
      process.exit(1)
    }
  }

  // Combine patterns with OR regex
  const grep = testNamePatterns.length > 0
    ? testNamePatterns.map(p => `(${p})`).join('|')
    : ''

  const params = new URLSearchParams()
  if (grep) params.set('grep', grep)
  if (filePattern) params.set('file', filePattern)
  if (invert) params.set('invert', '1')
  if (jsonMode) params.set('reporter', 'json')
  if (snapshotUpdate) params.set('snapshotUpdate', '1')

  const url = `http://localhost:${port}/test/run?${params}`

  // Build description
  let desc
  if (filePattern) {
    const filename = path.basename(filePattern)
    desc = testNamePatterns.length > 0
      ? `${filename} (${testNamePatterns.join('|')})`
      : filename
  } else {
    desc = testNamePatterns.length > 0
      ? testNamePatterns.join('|')
      : 'all tests'
  }
  // Only show running message in non-JSON mode
  if (!jsonMode) {
    console.log(`\nðŸ§ª Running tests (${desc})${invert ? ' (inverted)' : ''}...\n`)
  }

  let exitCode = 0
  let outputBuffer = ''
  let failureCount = 0
  let cachePromise = null
  let retrying = false
  let jsonResult = null // Parsed JSON from Mocha reporter
  const startTime = Date.now()

  function handleEvent(data) {
    switch (data.type) {
      case 'start':
        if (!jsonMode) {
          console.log(`${colors.dim}Starting: ${data.grep}${data.invert ? ' (inverted)' : ''}${colors.reset}`)
        }
        break

      case 'log':
        // Raw console output from Mocha (already has ANSI colors)
        if (!jsonMode) {
          console.log(data.data)
        }
        outputBuffer += data.data + '\n'
        break

      case 'error':
        if (data.data && data.data.includes('already running')) {
          if (!jsonMode) {
            console.log(`${colors.yellow}Tests already running - waiting 5s to retry...${colors.reset}`)
          }
          retrying = true
          setTimeout(() => runTests(), 5000)
          return // Don't continue processing
        }
        if (!jsonMode) {
          console.error(data.data)
        }
        outputBuffer += data.data + '\n'
        break

      case 'json':
        // Mocha JSON reporter output
        try {
          jsonResult = JSON.parse(data.data)
        } catch (e) {
          jsonResult = { parseError: e.message, raw: data.data }
        }
        break

      case 'done':
        exitCode = data.failures > 0 ? 1 : 0
        failureCount = data.failures

        if (jsonMode) {
          // Build final JSON output
          const duration = Date.now() - startTime
          const output = {
            success: exitCode === 0,
            grep: grep || null,
            file: filePattern || null,
            invert: invert || false,
            duration_ms: duration,
            hint: 'Fresh run. Results cached for 1 min unless source files change.',
            ...(jsonResult || {}),
          }
          console.log(JSON.stringify(output, null, 2))
        } else {
          console.log(`\n${colors.dim}Test run complete: ${data.failures} failures${colors.reset}\n`)
        }

        // Save to cache for full runs (store promise to await later)
        if (isFullRun) {
          cachePromise = saveCache(outputBuffer, exitCode, failureCount, jsonResult)
        }
        break

      case 'heartbeat':
        // Server is alive, tests running - handled by data event resetting lastActivity
        break
    }
  }

  // Make request
  const req = http.get(url, (res) => {
    if (res.statusCode !== 200) {
      console.error(`Error: Server returned ${res.statusCode}`)
      process.exit(1)
    }

    let buffer = ''
    let lastActivity = Date.now()
    let inactivityWarnings = 0

    // Mocha default timeout is 2s per test, so 15s of no output means we're hung
    // In JSON mode, abort and return error JSON
    const HANG_THRESHOLD_SECONDS = 15
    const inactivityCheck = setInterval(() => {
      const elapsed = Math.round((Date.now() - lastActivity) / 1000)
      if (elapsed >= HANG_THRESHOLD_SECONDS) {
        inactivityWarnings++
        if (jsonMode) {
          clearInterval(inactivityCheck)
          req.destroy()
          const output = {
            success: false,
            error: 'timeout',
            inactivity_seconds: elapsed,
            hint: `No test output for ${elapsed}s (Mocha timeout is 2s). Test is hung. Check: ./scripts/test-run daemon logs -t`,
            grep: grep || null,
            file: filePattern || null,
          }
          console.log(JSON.stringify(output, null, 2))
          process.exitCode = 1
        } else {
          console.log(`${colors.yellow}âš  No output for ${elapsed}s - test may be hung (Mocha timeout is 2s)${colors.reset}`)
          if (inactivityWarnings >= 2) {
            console.log(`${colors.dim}  Tip: Check daemon logs with: ./scripts/test-run daemon logs -t${colors.reset}`)
          }
        }
      }
    }, 5000) // Check every 5s

    res.on('data', (chunk) => {
      buffer += chunk
      const lines = buffer.split('\n\n')
      buffer = lines.pop() || '' // Keep incomplete chunk

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6))
            // Only reset activity timer on actual test output, not heartbeats
            // This way we detect hung tests even if connection is alive
            if (data.type !== 'heartbeat') {
              lastActivity = Date.now()
            }
            handleEvent(data)
          } catch (e) {
            // Ignore parse errors
          }
        }
      }
    })

    res.on('end', async () => {
      clearInterval(inactivityCheck)

      // If retrying due to "already running", don't exit
      if (retrying) return

      // Wait for cache to be saved before exiting
      if (cachePromise) {
        await cachePromise.catch(() => {}) // Ignore cache errors
      }

      if (watchMode) {
        // Watch mode: wait for daemon restart, then re-run
        console.log(`${colors.cyan}Watching for changes... (Ctrl+C to exit)${colors.reset}`)
        await waitForDaemonRestart()
        runTests() // Re-run with same parameters
      } else {
        // Use exitCode instead of exit() to allow stdout to flush when piped
        process.exitCode = exitCode
      }
    })
  })

  req.on('error', async (err) => {
    if (watchMode && err.code === 'ECONNREFUSED') {
      // Daemon went down - wait for it to come back
      console.log(`${colors.yellow}Daemon stopped, waiting for restart...${colors.reset}`)
      await waitForDaemonRestart()
      runTests()
    } else {
      console.error(`${colors.red}Error: ${err.message}${colors.reset}`)
      process.exit(1)
    }
  })
}

/**
 * Wait for daemon to restart (go down then come back up)
 */
async function waitForDaemonRestart() {
  // First wait for daemon to go down (if it's still up)
  let wasDown = false
  while (true) {
    const running = await isDaemonRunning()
    if (!running) {
      wasDown = true
    } else if (wasDown) {
      // Daemon is back up
      console.log(`\n${colors.green}Daemon restarted!${colors.reset}\n`)
      return
    }
    await new Promise(r => setTimeout(r, 500))
  }
}
