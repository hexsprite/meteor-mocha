#!/usr/bin/env node
/* eslint-disable no-console, max-len, complexity */
/**
 * CLI client for test daemon
 *
 * Usage:
 *   ./scripts/test-run                    # Run all tests
 *   ./scripts/test-run Calendar           # Filter by pattern
 *   ./scripts/test-run -t Calendar -t sync # Multiple patterns (OR)
 *   ./scripts/test-run Calendar -i        # Exclude pattern
 */

const http = require('http')

// Parse args
const args = process.argv.slice(2)
const testNamePatterns = []
let invert = false

for (let i = 0; i < args.length; i++) {
  const arg = args[i]

  // Test name patterns (-t, --testNamePattern, --grep, -g)
  if (arg === '-t' || arg === '--testNamePattern' || arg === '--grep' || arg === '-g') {
    if (args[i + 1]) testNamePatterns.push(args[++i])
  }
  // Invert
  else if (arg === '--invert' || arg === '-i') {
    invert = true
  }
  // Help
  else if (arg === '--help' || arg === '-h') {
    console.log(`
Usage: test-run [options] [pattern...]

Options:
  -t, --testNamePattern <pattern>  Filter by test name (can repeat)
  -g, --grep <pattern>             Alias for -t
  -i, --invert                     Invert pattern match
  -h, --help                       Show this help

Multiple patterns use OR logic.

Examples:
  test-run                           Run all tests
  test-run Calendar                  Tests matching "Calendar"
  test-run -t Calendar -t sync       Tests matching "Calendar" OR "sync"
  test-run Calendar -i               Exclude tests matching "Calendar"
`)
    process.exit(0)
  }
  // Positional args become test name patterns
  else if (!arg.startsWith('-')) {
    testNamePatterns.push(arg)
  }
}

// Combine patterns with OR regex
const grep = testNamePatterns.length > 0
  ? testNamePatterns.map(p => `(${p})`).join('|')
  : ''

const port = process.env.TEST_PORT || 9100
const params = new URLSearchParams()
if (grep) params.set('grep', grep)
if (invert) params.set('invert', '1')

const url = `http://localhost:${port}/test/run?${params}`

// Build description
const desc = testNamePatterns.length > 0
  ? testNamePatterns.join('|')
  : 'all tests'
console.log(`\nðŸ§ª Running tests (${desc})${invert ? ' (inverted)' : ''}...\n`)

// Colors
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  dim: '\x1b[2m',
  reset: '\x1b[0m',
}

let exitCode = 0

function handleEvent(data) {
  switch (data.type) {
    case 'start':
      console.log(`${colors.dim}Starting: ${data.grep}${data.invert ? ' (inverted)' : ''}${colors.reset}`)
      break

    case 'log':
      // Raw console output from Mocha (already has ANSI colors)
      console.log(data.data)
      break

    case 'error':
      console.error(data.data)
      break

    case 'done':
      exitCode = data.failures > 0 ? 1 : 0
      console.log(`\n${colors.dim}Test run complete: ${data.failures} failures${colors.reset}\n`)
      break
  }
}

// Make request
const req = http.get(url, (res) => {
  if (res.statusCode !== 200) {
    console.error(`Error: Server returned ${res.statusCode}`)
    console.error('Is the test daemon running? Start with: npm run test:daemon')
    process.exit(1)
  }

  let buffer = ''

  res.on('data', (chunk) => {
    buffer += chunk
    const lines = buffer.split('\n\n')
    buffer = lines.pop() || '' // Keep incomplete chunk

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        try {
          const data = JSON.parse(line.slice(6))
          handleEvent(data)
        } catch (e) {
          // Ignore parse errors
        }
      }
    }
  })

  res.on('end', () => {
    process.exit(exitCode)
  })
})

req.on('error', (err) => {
  if (err.code === 'ECONNREFUSED') {
    console.error(`${colors.red}Error: Cannot connect to test daemon${colors.reset}`)
    console.error('\nStart the daemon first:\n  npm run test:daemon\n')
  } else {
    console.error(`${colors.red}Error: ${err.message}${colors.reset}`)
  }
  process.exit(1)
})
